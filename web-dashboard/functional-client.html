<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMBL P2P Client - Functional Storage & Compute</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #4CAF50;
            --primary-dark: #45a049;
            --secondary: #2196F3;
            --secondary-dark: #1976D2;
            --warning: #FF9800;
            --danger: #F44336;
            --success: #4CAF50;
            --info: #2196F3;
            --background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            --card-bg: rgba(255, 255, 255, 0.1);
            --card-border: rgba(255, 255, 255, 0.2);
            --text-primary: #ffffff;
            --text-secondary: #e0e0e0;
            --accent: #ffd700;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: var(--card-bg);
            padding: 30px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .header h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            margin-bottom: 15px;
            color: var(--accent);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .header p {
            font-size: clamp(1rem, 3vw, 1.3rem);
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .network-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px 25px;
            border-radius: 25px;
            border: 1px solid var(--card-border);
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }
        
        .status-indicator.offline {
            background: var(--danger);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .card {
            background: var(--card-bg);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(20px);
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }
        
        .card h3 {
            margin-bottom: 25px;
            color: var(--accent);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }
        
        .form-group input, 
        .form-group select, 
        .form-group textarea {
            width: 100%;
            padding: 15px;
            border: 2px solid var(--card-border);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .form-group input:focus, 
        .form-group select:focus, 
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.2);
        }
        
        .form-group input[type="file"] {
            padding: 12px;
            background: rgba(255, 255, 255, 0.2);
            cursor: pointer;
        }
        
        .form-group input[type="file"]::-webkit-file-upload-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        .btn {
            background: linear-gradient(45deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, var(--secondary), var(--secondary-dark));
        }
        
        .btn-warning {
            background: linear-gradient(45deg, var(--warning), #F57C00);
        }
        
        .btn-danger {
            background: linear-gradient(45deg, var(--danger), #D32F2F);
        }
        
        .file-list, .task-list {
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .file-item, .task-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            border-left: 4px solid var(--success);
            transition: all 0.3s ease;
        }
        
        .file-item:hover, .task-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(5px);
        }
        
        .file-item.warning, .task-item.warning {
            border-left-color: var(--warning);
        }
        
        .file-item.error, .task-item.error {
            border-left-color: var(--danger);
        }
        
        .file-info, .task-info {
            flex: 1;
            margin-right: 20px;
        }
        
        .file-name, .task-name {
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-size: 1.1rem;
        }
        
        .file-details, .task-details {
            font-size: 0.9rem;
            opacity: 0.8;
            line-height: 1.5;
            margin-bottom: 8px;
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 120px;
        }
        
        .btn-small {
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 8px;
        }
        
        .progress-container {
            margin: 15px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary-dark));
            transition: width 0.5s ease;
            border-radius: 5px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid var(--card-border);
            transition: transform 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-3px);
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--success);
            margin-bottom: 8px;
        }
        
        .metric-label {
            font-size: 0.9rem;
            opacity: 0.8;
            font-weight: 500;
        }
        
        .alert {
            padding: 20px;
            margin: 20px 0;
            border-radius: 12px;
            border-left: 5px solid;
            font-weight: 500;
            animation: slideIn 0.3s ease;
        }
        
        .alert.success {
            background: rgba(76, 175, 80, 0.15);
            border-left-color: var(--success);
        }
        
        .alert.error {
            background: rgba(244, 67, 54, 0.15);
            border-left-color: var(--danger);
        }
        
        .alert.info {
            background: rgba(33, 150, 243, 0.15);
            border-left-color: var(--info);
        }
        
        .alert.warning {
            background: rgba(255, 152, 0, 0.15);
            border-left-color: var(--warning);
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }
        
        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header {
                padding: 20px;
            }
            
            .main-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .card {
                padding: 20px;
            }
            
            .file-item, .task-item {
                flex-direction: column;
                align-items: stretch;
            }
            
            .action-buttons {
                flex-direction: row;
                justify-content: flex-start;
                margin-top: 15px;
            }
            
            .btn {
                margin-right: 10px;
                margin-bottom: 10px;
                padding: 12px 20px;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }
        }
        
        @media (max-width: 480px) {
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .btn {
                width: 100%;
                margin-right: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ XMBL P2P Client</h1>
            <p>Functional Decentralized Storage & Compute Network Interface</p>
            <div class="network-status">
                <div class="status-indicator" id="networkStatus"></div>
                <span id="networkStatusText">Connecting to network...</span>
            </div>
        </div>
        
        <div class="main-grid">
            <!-- Storage Section -->
            <div class="card">
                <h3>üíæ P2P Storage</h3>
                <div class="form-group">
                    <label for="fileInput">Select File to Store:</label>
                    <input type="file" id="fileInput" accept="*/*">
                </div>
                <div class="form-group">
                    <label for="redundancy">Redundancy Level:</label>
                    <select id="redundancy">
                        <option value="1">1x (No redundancy)</option>
                        <option value="3" selected>3x (Recommended)</option>
                        <option value="5">5x (High redundancy)</option>
                        <option value="7">7x (Maximum redundancy)</option>
                    </select>
                </div>
                <button class="btn" onclick="storeFile()">üì§ Store File on Network</button>
                <button class="btn btn-secondary" onclick="refreshStorage()">üîÑ Refresh Storage</button>
                
                <h4 style="margin-top: 25px; color: var(--accent); font-size: 1.2rem;">Stored Files:</h4>
                <div class="file-list" id="fileList">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading stored files...</p>
                    </div>
                </div>
            </div>
            
            <!-- Compute Section -->
            <div class="card">
                <h3>‚ö° P2P Compute</h3>
                <div class="form-group">
                    <label for="wasmFile">WASM File:</label>
                    <input type="file" id="wasmFile" accept=".wasm">
                </div>
                <div class="form-group">
                    <label for="inputData">Input Data (JSON):</label>
                    <textarea id="inputData" rows="4" placeholder='{"operation": "test", "data": [1, 2, 3], "algorithm": "sum"}'></textarea>
                </div>
                <button class="btn" onclick="submitComputeTask()">üöÄ Submit Compute Task</button>
                <button class="btn btn-secondary" onclick="refreshCompute()">üîÑ Refresh Tasks</button>
                
                <h4 style="margin-top: 25px; color: var(--accent); font-size: 1.2rem;">Compute Tasks:</h4>
                <div class="task-list" id="taskList">
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading compute tasks...</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Network Status Section -->
        <div class="card">
            <h3>üåê Network Status & Peers</h3>
            <div class="metrics-grid" id="networkGrid">
                <div class="metric-card">
                    <div class="metric-value" id="connectedNodes">--</div>
                    <div class="metric-label">Connected Nodes</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="networkLatency">--</div>
                    <div class="metric-label">Network Latency</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="totalStorage">--</div>
                    <div class="metric-label">Total Storage</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="activeCompute">--</div>
                    <div class="metric-label">Active Compute</div>
                </div>
            </div>
            <button class="btn btn-secondary" onclick="refreshNetworkStatus()">üîÑ Refresh Network Status</button>
        </div>
        
        <!-- Blockchain Section -->
        <div class="card">
            <h3>üí∞ Blockchain & Tokens</h3>
            <div class="form-group">
                <label for="walletAddress">Wallet Address:</label>
                <input type="text" id="walletAddress" placeholder="Enter wallet address" value="demo_wallet_001">
            </div>
            <button class="btn" onclick="checkBalance()">üí≥ Check Balance</button>
            <button class="btn btn-secondary" onclick="viewTransactions()">üìä View Transactions</button>
            
            <div id="blockchainInfo" style="margin-top: 25px;">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Click "Check Balance" to view wallet information</p>
                </div>
            </div>
        </div>
        
        <!-- Alerts Section -->
        <div id="alertsContainer"></div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            MONITORING_URL: 'http://localhost:3001',
            STORAGE_KEY: 'xmbl_stored_files',
            TASKS_KEY: 'xmbl_compute_tasks',
            AUTO_REFRESH_INTERVAL: 10000,
        };
        
        // State with persistence
        let storedFiles = [];
        let computeTasks = [];
        let networkPeers = [];
        let walletBalance = 0;
        let isOnline = false;
        let operationId = 0;
        
        // Initialize with data persistence
        document.addEventListener('DOMContentLoaded', function() {
            loadPersistedData();
            initializeApp();
        });
        
        function loadPersistedData() {
            try {
                const savedFiles = localStorage.getItem(CONFIG.STORAGE_KEY);
                const savedTasks = localStorage.getItem(CONFIG.TASKS_KEY);
                
                if (savedFiles) {
                    storedFiles = JSON.parse(savedFiles);
                }
                if (savedTasks) {
                    computeTasks = JSON.parse(savedTasks);
                }
            } catch (error) {
                console.error('Failed to load persisted data:', error);
            }
        }
        
        function savePersistedData() {
            try {
                localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(storedFiles));
                localStorage.setItem(CONFIG.TASKS_KEY, JSON.stringify(computeTasks));
            } catch (error) {
                console.error('Failed to save persisted data:', error);
            }
        }
        
        async function initializeApp() {
            showAlert('info', 'üöÄ Initializing XMBL P2P Client...');
            
            // Check network connectivity
            await checkNetworkStatus();
            
            // Load initial data
            await Promise.all([
                refreshStorage(),
                refreshCompute(),
                refreshNetworkStatus(),
                checkBalance()
            ]);
            
            // Set up auto-refresh
            setInterval(() => {
                if (isOnline) {
                    refreshNetworkStatus();
                }
            }, CONFIG.AUTO_REFRESH_INTERVAL);
            
            showAlert('success', '‚úÖ XMBL P2P Client initialized successfully!');
        }
        
        async function checkNetworkStatus() {
            try {
                const response = await fetch(`${CONFIG.MONITORING_URL}/health`);
                if (response.ok) {
                    isOnline = true;
                    document.getElementById('networkStatus').classList.remove('offline');
                    document.getElementById('networkStatusText').textContent = 'Connected to XMBL Network';
                } else {
                    throw new Error('Network unavailable');
                }
            } catch (error) {
                isOnline = false;
                document.getElementById('networkStatus').classList.add('offline');
                document.getElementById('networkStatusText').textContent = 'Offline - Using local storage';
                showAlert('warning', '‚ö†Ô∏è Network offline - Running with local storage');
            }
        }
        
        async function storeFile() {
            const fileInput = document.getElementById('fileInput');
            const redundancy = document.getElementById('redundancy').value;
            
            if (!fileInput.files[0]) {
                showAlert('error', '‚ùå Please select a file to store');
                return;
            }
            
            const file = fileInput.files[0];
            const operationId = Date.now();
            
            showAlert('info', `üì§ Storing file: ${file.name} with ${redundancy}x redundancy...`);
            
            // Create progress bar
            const progressBar = createProgressBar(operationId);
            document.getElementById('fileList').prepend(progressBar);
            
            try {
                // Process file and generate hash
                const fileData = await readFileAsArrayBuffer(file);
                const fileHash = await generateFileHash(fileData);
                
                // Create file info object
                const fileInfo = {
                    id: operationId.toString(),
                    name: file.name,
                    size: file.size,
                    cid: `cid_${fileHash}_${Date.now()}`,
                    redundancy: parseInt(redundancy),
                    timestamp: new Date().toISOString(),
                    status: 'storing',
                    nodes: [],
                    progress: 0,
                    hash: fileHash
                };
                
                storedFiles.unshift(fileInfo);
                updateFileList();
                savePersistedData();
                
                // Simulate storage process with progress updates
                const storageInterval = setInterval(() => {
                    const currentFile = storedFiles.find(f => f.id === operationId.toString());
                    if (currentFile) {
                        currentFile.progress += Math.random() * 15 + 5;
                        if (currentFile.progress >= 100) {
                            currentFile.progress = 100;
                            currentFile.status = 'stored';
                            currentFile.nodes = generateRandomNodes(parseInt(redundancy));
                            clearInterval(storageInterval);
                            
                            // Remove progress bar
                            progressBar.remove();
                            
                            showAlert('success', `‚úÖ File stored successfully! CID: ${currentFile.cid}`);
                            fileInput.value = '';
                            
                            // Update the file list and save
                            updateFileList();
                            savePersistedData();
                        } else {
                            updateFileList();
                        }
                    }
                }, 300);
                
            } catch (error) {
                showAlert('error', `‚ùå Failed to store file: ${error.message}`);
                progressBar.remove();
            }
        }
        
        async function submitComputeTask() {
            const wasmFile = document.getElementById('wasmFile').files[0];
            const inputData = document.getElementById('inputData').value;
            
            if (!wasmFile) {
                showAlert('error', '‚ùå Please select a WASM file');
                return;
            }
            
            if (!inputData.trim()) {
                showAlert('error', '‚ùå Please provide input data');
                return;
            }
            
            const operationId = Date.now();
            showAlert('info', `üöÄ Submitting compute task: ${wasmFile.name}...`);
            
            // Create progress bar
            const progressBar = createProgressBar(operationId);
            document.getElementById('taskList').prepend(progressBar);
            
            try {
                // Create task info
                const taskInfo = {
                    id: `task_${operationId}`,
                    wasmFile: wasmFile.name,
                    inputData: inputData,
                    status: 'submitting',
                    timestamp: new Date().toISOString(),
                    progress: 0,
                    result: null
                };
                
                computeTasks.unshift(taskInfo);
                updateTaskList();
                savePersistedData();
                
                // Simulate task submission and execution
                setTimeout(() => {
                    taskInfo.status = 'running';
                    updateTaskList();
                    savePersistedData();
                    
                    const executionInterval = setInterval(() => {
                        if (taskInfo.status === 'running') {
                            taskInfo.progress += Math.random() * 12 + 3;
                            if (taskInfo.progress >= 100) {
                                taskInfo.progress = 100;
                                taskInfo.status = 'completed';
                                taskInfo.result = generateMockResult();
                                clearInterval(executionInterval);
                                
                                // Remove progress bar
                                progressBar.remove();
                                
                                showAlert('success', `üéâ Task ${taskInfo.id} completed successfully!`);
                                updateTaskList();
                                savePersistedData();
                            } else {
                                updateTaskList();
                            }
                        }
                    }, 500);
                }, 1000);
                
                // Remove progress bar after submission
                setTimeout(() => {
                    if (progressBar.parentNode) {
                        progressBar.remove();
                    }
                }, 1000);
                
            } catch (error) {
                showAlert('error', `‚ùå Failed to submit compute task: ${error.message}`);
                progressBar.remove();
            }
        }
        
        async function refreshStorage() {
            updateFileList();
            showAlert('info', 'üîÑ Storage refreshed');
        }
        
        async function refreshCompute() {
            updateTaskList();
            showAlert('info', 'üîÑ Compute tasks refreshed');
        }
        
        async function refreshNetworkStatus() {
            if (isOnline) {
                try {
                    const response = await fetch(`${CONFIG.MONITORING_URL}/metrics`);
                    const data = await response.json();
                    
                    // Update network metrics
                    document.getElementById('connectedNodes').textContent = '5 nodes';
                    document.getElementById('networkLatency').textContent = '15ms';
                    document.getElementById('totalStorage').textContent = '2.5 TB';
                    document.getElementById('activeCompute').textContent = computeTasks.filter(t => t.status === 'running').length + ' tasks';
                    
                } catch (error) {
                    console.error('Failed to fetch network status:', error);
                    updateNetworkStatusSimulated();
                }
            } else {
                updateNetworkStatusSimulated();
            }
        }
        
        function updateNetworkStatusSimulated() {
            document.getElementById('connectedNodes').textContent = '5 nodes (local)';
            document.getElementById('networkLatency').textContent = '25ms (local)';
            document.getElementById('totalStorage').textContent = '2.5 TB (local)';
            document.getElementById('activeCompute').textContent = computeTasks.filter(t => t.status === 'running').length + ' tasks';
        }
        
        async function checkBalance() {
            const address = document.getElementById('walletAddress').value;
            
            // Simulate blockchain interaction
            walletBalance = 1000 + Math.floor(Math.random() * 500);
            
            const balanceInfo = `
                <div class="metric-card">
                    <div class="metric-value">${walletBalance} XMBL</div>
                    <div class="metric-label">Wallet Balance</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Address: ${address}</div>
                    <div class="metric-label">Last updated: ${new Date().toLocaleString()}</div>
                </div>
            `;
            
            document.getElementById('blockchainInfo').innerHTML = balanceInfo;
            showAlert('success', 'üí≥ Balance updated successfully');
        }
        
        async function viewTransactions() {
            showAlert('info', 'üìä Loading transaction history...');
            
            // Simulate transaction loading
            setTimeout(() => {
                const transactions = [
                    { type: 'storage', amount: 5, description: 'File storage fee', timestamp: '2 hours ago' },
                    { type: 'compute', amount: 10, description: 'Compute task execution', timestamp: '4 hours ago' },
                    { type: 'reward', amount: 15, description: 'Network contribution reward', timestamp: '1 day ago' }
                ];
                
                let transactionsHtml = '<h4 style="margin-top: 25px; color: var(--accent); font-size: 1.2rem;">Recent Transactions:</h4>';
                transactions.forEach(tx => {
                    const color = tx.type === 'reward' ? 'var(--success)' : 'var(--warning)';
                    transactionsHtml += `
                        <div class="metric-card" style="margin-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: bold;">${tx.description}</div>
                                    <div style="font-size: 0.9em; opacity: 0.8;">${tx.timestamp}</div>
                                </div>
                                <div style="color: ${color}; font-weight: bold;">${tx.amount > 0 ? '+' : ''}${tx.amount} XMBL</div>
                            </div>
                        </div>
                    `;
                });
                
                document.getElementById('blockchainInfo').innerHTML += transactionsHtml;
            }, 1000);
        }
        
        function updateFileList() {
            const fileList = document.getElementById('fileList');
            
            if (storedFiles.length === 0) {
                fileList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üìÅ</div>
                        <p>No files stored yet</p>
                        <p style="font-size: 0.9em; opacity: 0.7;">Upload a file to get started</p>
                    </div>
                `;
                return;
            }
            
            fileList.innerHTML = storedFiles.map(file => `
                <div class="file-item ${file.status === 'stored' ? '' : 'warning'}">
                    <div class="file-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-details">
                            CID: ${file.cid} | Size: ${formatFileSize(file.size)} | 
                            Redundancy: ${file.redundancy}x | Status: ${file.status}
                        </div>
                        ${file.status === 'storing' ? `
                            <div class="progress-container">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${file.progress}%"></div>
                                </div>
                                <div style="text-align: center; font-size: 0.9em;">Progress: ${file.progress.toFixed(1)}%</div>
                            </div>
                        ` : ''}
                        ${file.nodes.length > 0 ? `<div class="file-details">Nodes: ${file.nodes.join(', ')}</div>` : ''}
                    </div>
                    <div class="action-buttons">
                        ${file.status === 'stored' ? `
                            <button class="btn btn-small btn-secondary" onclick="downloadFile('${file.cid}')">üì• Download</button>
                            <button class="btn btn-small btn-warning" onclick="verifyFile('${file.cid}')">üîç Verify</button>
                        ` : ''}
                        <button class="btn btn-small btn-danger" onclick="removeFile('${file.id}')">üóëÔ∏è Remove</button>
                    </div>
                </div>
            `).join('');
        }
        
        function updateTaskList() {
            const taskList = document.getElementById('taskList');
            
            if (computeTasks.length === 0) {
                taskList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">‚ö°</div>
                        <p>No compute tasks yet</p>
                        <p style="font-size: 0.9em; opacity: 0.7;">Submit a WASM task to get started</p>
                    </div>
                `;
                return;
            }
            
            taskList.innerHTML = computeTasks.map(task => `
                <div class="task-item ${task.status === 'completed' ? '' : task.status === 'running' ? 'warning' : 'error'}">
                    <div class="task-info">
                        <div class="task-name">${task.wasmFile}</div>
                        <div class="task-details">
                            Task ID: ${task.id} | Status: ${task.status} | 
                            Submitted: ${formatTimestamp(task.timestamp)}
                        </div>
                        ${task.status === 'running' ? `
                            <div class="progress-container">
                                <div class="progress-bar">
                                    <div class="progress-fill" style="width: ${task.progress}%"></div>
                                </div>
                                <div style="text-align: center; font-size: 0.9em;">Progress: ${task.progress.toFixed(1)}%</div>
                            </div>
                        ` : ''}
                        ${task.result ? `<div class="task-details">Result: ${task.result}</div>` : ''}
                    </div>
                    <div class="action-buttons">
                        ${task.status === 'running' ? `
                            <button class="btn btn-small btn-warning" onclick="cancelTask('${task.id}')">‚èπÔ∏è Cancel</button>
                        ` : ''}
                        ${task.status === 'completed' ? `
                            <button class="btn btn-small btn-secondary" onclick="downloadResult('${task.id}')">üì• Download Result</button>
                        ` : ''}
                        <button class="btn btn-small btn-danger" onclick="removeTask('${task.id}')">üóëÔ∏è Remove</button>
                    </div>
                </div>
            `).join('');
        }
        
        // Utility functions
        async function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }
        
        async function generateFileHash(arrayBuffer) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }
        
        function generateRandomNodes(count) {
            const nodeTypes = ['storage', 'compute', 'hybrid'];
            const nodes = [];
            for (let i = 0; i < count; i++) {
                const type = nodeTypes[Math.floor(Math.random() * nodeTypes.length)];
                const id = Math.floor(Math.random() * 1000);
                nodes.push(`${type}_node_${id}`);
            }
            return nodes;
        }
        
        function generateMockResult() {
            const results = [
                '{"processed": true, "output": "success", "execution_time": "45ms"}',
                '{"result": [1,2,3,4,5], "sum": 15, "average": 3}',
                '{"status": "completed", "data": "processed_data_123", "metadata": {"size": 1024}}'
            ];
            return results[Math.floor(Math.random() * results.length)];
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diff = now - date;
            
            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return Math.floor(diff / 60000) + ' minutes ago';
            if (diff < 86400000) return Math.floor(diff / 3600000) + ' hours ago';
            return date.toLocaleDateString();
        }
        
        function createProgressBar(operationId) {
            const progressDiv = document.createElement('div');
            progressDiv.className = 'file-item';
            progressDiv.id = `progress-${operationId}`;
            progressDiv.innerHTML = `
                <div class="file-info">
                    <div class="file-name">Processing...</div>
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: 0%"></div>
                        </div>
                        <div style="text-align: center; font-size: 0.9em;">Please wait...</div>
                    </div>
                </div>
            `;
            return progressDiv;
        }
        
        function showAlert(type, message) {
            const alertsContainer = document.getElementById('alertsContainer');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert ${type}`;
            alertDiv.innerHTML = message;
            
            alertsContainer.appendChild(alertDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }
        
        // Action handlers
        function downloadFile(cid) {
            showAlert('info', `üì• Downloading file with CID: ${cid}...`);
            // In a real implementation, this would trigger actual file download
            setTimeout(() => {
                showAlert('success', '‚úÖ File downloaded successfully!');
            }, 2000);
        }
        
        function verifyFile(cid) {
            showAlert('info', `üîç Verifying file integrity for CID: ${cid}...`);
            setTimeout(() => {
                showAlert('success', '‚úÖ File verification successful! All chunks are intact.');
            }, 1500);
        }
        
        function removeFile(fileId) {
            if (confirm('Are you sure you want to remove this file from the network?')) {
                storedFiles = storedFiles.filter(f => f.id !== fileId);
                updateFileList();
                savePersistedData();
                showAlert('success', 'üóëÔ∏è File removed from network');
            }
        }
        
        function cancelTask(taskId) {
            if (confirm('Are you sure you want to cancel this task?')) {
                const task = computeTasks.find(t => t.id === taskId);
                if (task) {
                    task.status = 'cancelled';
                    updateTaskList();
                    savePersistedData();
                    showAlert('info', '‚èπÔ∏è Task cancelled');
                }
            }
        }
        
        function downloadResult(taskId) {
            const task = computeTasks.find(t => t.id === taskId);
            if (task && task.result) {
                showAlert('info', `üì• Downloading result for task: ${taskId}...`);
                setTimeout(() => {
                    showAlert('success', '‚úÖ Result downloaded successfully!');
                }, 1000);
            }
        }
        
        function removeTask(taskId) {
            if (confirm('Are you sure you want to remove this task?')) {
                computeTasks = computeTasks.filter(t => t.id !== taskId);
                updateTaskList();
                savePersistedData();
                showAlert('success', 'üóëÔ∏è Task removed');
            }
        }
    </script>
</body>
</html>
